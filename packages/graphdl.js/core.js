// âˆµ GraphDL: GraphDL is a graph-based data language for describing data models and data relationships.

// ðŸœ‰ Graph:
//   nouns:          [Noun.graph]

// â–  Noun:
//   _id:            string = slugify(_name)
//   _icon:          string | url = â– 
//   _name:          string = titleCase(_id)
//   _type:          string = Noun
//   _description:   markdown | html
//   _source:        url | [string] | [object]
//   _seed:          url | [string] | [object]
//   _visibility:    anonymous | public | tenant | user | admin = tenant
//   _graph:         Graph.nouns
//   ${property}:    Properties | `[${Properties}]` | `${Properties}!` | `${Nouns}` | `[${Nouns}]` | `${Nouns}.${property}` | `[${Nouns}.${property}]`

// âˆ· Properties:     string | markdown | url | email | phone | date | time | datetime | timestamp | number | integer | currency | boolean | object

export const init = graphdl => {
  const graph = { 
    // nouns: { },
    // verbs: { },
  }
  Object.entries(graphdl).map(([key, val]) => {
    if (key === 'import') {
      // TODO: import other GraphDL, JSON Schema, JSON-LD, JavaScript, and TypeScript files
      graph.import = val
    } else if (key.startsWith('_')) {
      // Get Graph-level properties
      graph[key] = val

    // Get ID, Icon, Noun, & Description from Abbreviated Syntax like:
    // âˆµ GraphDL: GraphDL is a graph-based data language for describing data models and data relationships.
    } else if (isString(val)) {
      graph._id = slugify(getNoun(key))
      graph._name = getNoun(key)
      graph._icon = getIcon(key)
      graph._description = val

    // Otherwise get the Noun and its properties
    // ðŸœ‰ Graph:
    //   _description:   A [Graph] consists of [Noun]s and the [Verb]s that connect them.
    //   nouns:          [Noun.graph]
    //   verbs:          [Verb]
    } else if (isObject(val)) {
      const noun = getNoun(key)
      if (!graph.nouns) graph.nouns = { }
      graph.nouns[noun] = { }
      graph.nouns[noun]._id = slugify(noun)
      graph.nouns[noun]._name = noun
      graph.nouns[noun]._icon = getIcon(key)
      graph.nouns[noun]._properties = Object.entries(val).map(([property, value]) => {
        // if (property.includes('.')) {
        console.log(value)
        const [ props, defaultValue ] = isArray(value) ? value : value.split(' = ')
        const required = props.includes('!') ? true : undefined
        const many = props.startsWith('[') && propertyType.endsWith(']') ? true : undefined
        const options = props.includes(',') ? props.split(',').map(i => i.trim()) : undefined
        const types = props.includes(' | ') ? props.split(' | ').map(propertyType => {
          // TODO: Identify if an array or not
          // TODO: Identify if a property is required or not
          // TODO: Identify if a property is a relationship to another Noun
          // TODO: Identify if a Noun relationship is embedded, referenced, or looked up
          const propMany = propertyType.startsWith('[') && propertyType.endsWith(']') ? true : undefined
          const propType = propertyType.replace('[', '').replace(']', '')
          const [ referencedNoun, referencedProperty ] = propType.includes('.') ? propType.split('.') : []
          const [ lookupNoun, lookupProperty ] = propType.includes('->') ? propType.split('->') : []
          const embeddedNoun = (propType.slice(0, 1).match(/[A-Z]/g)) ? propType : undefined
          const object = embeddedNoun || referencedNoun || lookupNoun
          const verb = referencedProperty || lookupProperty || property //'has' //property

          if (object) {
            if (!graph.verbs) graph.verbs = { }
            graph.verbs[`${noun}.${verb}->${object}`] = {
              _id: `${noun}.${verb}->${object}`,
              _subject: noun,
              _action: verb,
              _object: object,
            }
          }
          return { type: propType, many: propMany, referencedNoun, referencedProperty, lookupNoun, lookupProperty, embeddedNoun }
        }) : undefined
        const type = types ? undefined : options ? 'string' : props
        return { name: property, type, required, many, options, types, defaultValue }
      })

      // TODO: Identify Noun relationships and add to graph.verbs
    
    // TODO: identify edge cases and define default behavior
    } else {

    }
  })
  return graph
}

export const compose = graphs => {
  let layers = isArray(graphs) ? graphs : Object.entries(graphs).map(([key, val]) => ({ _layer: slugify(key), ...val }))
  console.log(layers)
  return layers
}

export const generateJavascript = graph => `// Generated by GraphDL
${graph.nouns.map(noun => `export const ${noun._id} = { }`)}
`
const getNoun = str => str.match(/[A-Za-z]+/g)?.join('')
const getIcon = str => str.match(/[^A-Za-z ]+/g)?.join('')

const isString = str => typeof str === 'string'
const isObject = obj => typeof obj === 'object'
const isArray = arr => Array.isArray(arr)

const slugify = str => str?.toString()
    .toLowerCase()
    .replace(/\s+/g, '-')           // Replace spaces with -
    .replace(/[^\w\-]+/g, '')       // Remove all non-word chars
    .replace(/\-\-+/g, '-')         // Replace multiple - with single -
    .replace(/^-+/, '')             // Trim - from start of text
    .replace(/-+$/, '')             // Trim - from end of text  
